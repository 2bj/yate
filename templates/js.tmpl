// vim: set filetype=javascript:

// ----------------------------------------------------------------------------------------------------------------- //
// module
// ----------------------------------------------------------------------------------------------------------------- //

// На первое время, шаблоны (и соответственно matcher) выводятся только на верхнем уровне.

module

    (function() {

        var M = new yr.Module();

        %{ defs :module }

        M.matcher = %{ js__matcher() };

        yr.register('%{ Name }', M);

    })();

// ----------------------------------------------------------------------------------------------------------------- //
// defs: template, function_, key, var_
// ----------------------------------------------------------------------------------------------------------------- //

// template.

template :module

    // match %{ Selector :yate } %{ Mode :yate }
    M.t%{ Tid } = %{ . :def };
    M.t%{ Tid }.s = %{ Selector :selector_ref };

template :def
    function t%{ Tid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid }%{ Args }) {
        %{ Args :defaults }
        %{ . :template_prologue }

        %{ Body :output }

        return r%{ Rid };
    }
//template :template_prologue [ this.type() === 'array' ]
//
//    var r%{ Rid } = [];
//
//template :template_prologue [ this.type() === 'object' ]
//
//    var r%{ Rid } = {};

template :template_prologue

    var r%{ Rid } = '';


// ----------------------------------------------------------------------------------------------------------------- //

// function_

function_ :module

    // func %{ Name }(%{ Args :yate }) : %{ type() }
    M.f%{ Fid } = %{ . :def };

//  Только функции с типом attr или xml используют параметр aN.
function_ :def [ this.type() === 'attr' || this.type() === 'xml' ]

    function f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid }%{ Args }) {
        %{ . :function_body }
    }

function_ :def

    function f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }%{ Args }) {
        %{ . :function_body }
    }

//  Тело функции состоит из одного инлайнового выражения (без каких-либо определений).
* :function_body [ this.Body.inline() ]
    %{ Args :defaults }

    return %{ Body };

* :function_body

    %{ Args :defaults }
    %{ . :function_prologue }

    %{ Body :output }

    %{ . :function_epilogue }


* :function_prologue [ this.type() === 'nodeset' ]

    var r%{ Rid } = [];

* :function_prologue [ this.type() === 'boolean' ]

    var r%{ Rid } = false;

//  Функция типа attr не использует переменную rN.
* :function_prologue [ this.type() !== 'attr' ]

    var r%{ Rid } = '';


* :function_epilogue [ this.type() === 'attr' ]

    return a%{ Rid }.attrs;

* :function_epilogue

    return r%{ Rid };


// ----------------------------------------------------------------------------------------------------------------- //

//  var_

var_ :module
    %{ . :comment }
    M.v%{ Vid } = %{ . :def };

var_ :comment [ this.Value.inline() ]
    //  %{ Name } = %{ Value :yate }

var_ :comment
    //  %{ Name }

var_ :def [ this.Value.inline() && this.Value.isConst() ]
    %{ Value }

var_ :def [ this.Value.inline() ]
    function(c0, i0, l0) {
        return %{ Value };
    }

var_ :def [ this.Value.type() === 'attr' ]
    function(c0, i0, l0) {
        %{ Value :prologue }
        %{ Value :output }
        return a%{ Value.Rid }.attrs;
    }

var_ :def
    function(c0, i0, l0) {
        %{ Value :prologue }
        %{ Value :output }
        return r%{ Value.Rid };
    }


// ----------------------------------------------------------------------------------------------------------------- //

key :module

    M.k%{ Kid } = {};
    M.k%{ Kid }.n = %{ . :nodes };
    M.k%{ Kid }.u = %{ . :use };
    M.k%{ Kid }.b = %{ . :body };

key :nodes

    function k%{ Kid }n(c0, i0, l0) {
        return %{ Nodes };
    }

key :use

    function k%{ Kid}u(c0, i0, l0) {
        return %{ Use };
    }

key :body

    function k%{ Kid }b(c0, i0, l0) {
        %{ . :function_body }
    }


// ----------------------------------------------------------------------------------------------------------------- //

//  jpath

//  FIXME: Нужно не выводить "простые" jpath'ы, но при этом только те,
//  которые используются только как скаляры.
jpath :module

    // %{ Key }
    M.j%{ Jid } = %{ . :def };

jpath :def

    [ %{ Steps } ]

jpath_nametest

    0, '%{ Name }'

jpath_dots

    1, %{ Length }

jpath_predicate [ this.isLocal() ]

    2, 'p%{ Pid }'

jpath_predicate

    3, 'p%{ Pid }'

// ----------------------------------------------------------------------------------------------------------------- //

//  jpath_predicate

jpath_predicate :module

    // %{ Key }
    M.p%{ Pid } = %{ . :def };

jpath_predicate :def

    function p%{ Pid }(c%{ Cid }, i%{ Cid }, l%{ Cid }) {
// FIXME: Если тут не добавить объявление a0, то ломается тест ../tests/functions.17.yate.
        var a%{ Rid } = null;
        return %{ Expr };
    }


// ----------------------------------------------------------------------------------------------------------------- //
// block and body
// ----------------------------------------------------------------------------------------------------------------- //

body

    %{ Block }

body :output

    %{ Block :output }


// ----------------------------------------------------------------------------------------------------------------- //

block

    %{ Exprs }

block :output

    %{ Exprs :output }

* :prologue [ this.type() === 'nodeset' ]

    var r%{ Rid } = [];

* :prologue [ this.type() === 'boolean' ]

    var r%{ Rid } = false;

* :prologue

    var r%{ Rid } = '';
    var a%{ Rid } = { attrs: {} };


// ----------------------------------------------------------------------------------------------------------------- //
// block expressions
// ----------------------------------------------------------------------------------------------------------------- //

if_ :output [ this.Else ]

    if (%{ Condition }) {
        %{ Then :output }
    } else {
        %{ Else :output }
    }

if_ :output

    if (%{ Condition }) {
        %{ Then :output }
    }

// ----------------------------------------------------------------------------------------------------------------- //

for_ :output

    var items%{ Cid } = %{ Selector };
    for (var i%{ Body.Cid } = 0, l%{ Body.Cid } = items%{ Cid }.length; i%{ Body.Cid } < l%{ Body.Cid }; i%{ Body.Cid }++) {
        var c%{ Body.Cid } = items%{ Cid }[ i%{ Body.Cid } ];
        %{ Body :output }
    }

// ----------------------------------------------------------------------------------------------------------------- //

apply :output

    r%{ Rid } += this.applyValue(%{ Expr }, %{ Mode :string }, a%{ Rid }%{ Args });

template_mode :string

    '%{ Value }'

// ----------------------------------------------------------------------------------------------------------------- //

xml_attr :open

    '%{ Name }': %{ Value }

xml_line :output

    r%{ Rid } += %{ . :content };

xml_line :content

    %{ js__content() }


// ----------------------------------------------------------------------------------------------------------------- //

// FIXME: Закэшировать a0.attrs в отдельную переменную.
attr :output [ this.Value.inline() && this.Op === '+=' ]
    a%{ Rid }.attrs[ %{ Name } ] = (a%{ Rid }.attrs[ %{ Name } ] || '') + %{ Value };

attr :output [ this.Value.inline() ]
    a%{ Rid }.attrs[ %{ Name } ] %{ Op } %{ Value };

attr :output [ this.Op === '+=' ]

    %{ Value :prologue }
    %{ Value :output }
    a%{ Rid }.attrs[ %{ Name } ] = (a%{ Rid }.attrs[ %{ Name } ] || '') + r%{ Value.Rid };

attr :output

    %{ Value :prologue }
    %{ Value :output }
    a%{ Rid }.attrs[ %{ Name } ] %{ Op } r%{ Value.Rid };

attrs_close :output
    r%{ Rid } += this.closeAttrs(a%{ Rid });

attrs_open :output

    a%{ Rid }.attrs = {
        %{ Attrs :open }
    };
    a%{ Rid }.start = '%{ Name }';



// ----------------------------------------------------------------------------------------------------------------- //

subexpr :output

    %{ Block :output }



// ----------------------------------------------------------------------------------------------------------------- //
// Selectors: jpath and root.
// ----------------------------------------------------------------------------------------------------------------- //

root

    c0.root

// Для jpath выводим имя его переменной, для root -- null.

root :selector_ref

    null

jpath :selector_ref

    "j%{ Jid }"

jpath [ this.yate() === '.' ]

    [ c%{ Cid } ]

jpath

    this.select('j%{ Jid }', c%{ Cid })

// FIXME: Переименовать в inline_filter
jpath_filter

    this.select('j%{ JPath.Jid }', %{ Expr })



// ----------------------------------------------------------------------------------------------------------------- //

arglist_item
    , v%{ Vid }

arglist_item :defaults [ this.Default ]
    v%{ Vid } = v%{ Vid } || %{ Default };


// ----------------------------------------------------------------------------------------------------------------- //
//  value
// ----------------------------------------------------------------------------------------------------------------- //

value

    %{ Value }

value :output [ ( this.type() === 'nodeset' || this.type() === 'boolean' ) && !this.AsType ]

    r%{ Rid } = %{ Value };

value :output [ this.type() === 'attr' && this.Value.is('inline_var') ]

    this.copyAttrs( a%{ Rid }.attrs, %{ Value } );

//  А тут всегда Value должно быть inline_function.
value :output [ this.type() === 'attr' ]

    %{ Value };

value :output

    r%{ Rid } += %{ Value };


// ----------------------------------------------------------------------------------------------------------------- //
// inline expressions
// ----------------------------------------------------------------------------------------------------------------- //

inline_or
    %{ Left } || %{ Right }

inline_and
    %{ Left } && %{ Right }

inline_not
    !%{ Left }

inline_eq
    %{ Left } %{ Op } %{ Right }

inline_rel
    %{ Left } %{ Op } %{ Right }

inline_add
    %{ Left } %{ Op } %{ Right }

inline_mul
    %{ Left } %{ Op } %{ Right }

inline_unary
    -%{ Expr }

inline_union
    (%{ Left }).concat(%{ Right })

inline_subexpr
    (%{ Expr })



// ----------------------------------------------------------------------------------------------------------------- //

//  FIXME: Нужно ли тут передавать aN?
inline_function [ this.External ]
    (Yater.externals['%{ Name }'])(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid }%{ Args })

inline_function [ this.Kid != null ]
    k%{ Kid }(%{ Args }, root)

//  Этот вызов функции сохраняется в переменную, а не просто используется.
//  Поэтому мы передаем вместо aN новый пустой объект для атрибутов.
inline_function [ this.Fid != null && this.type() === 'attr' && this.InlineVarValue ]
    f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, { attrs: {} }%{ Args })

inline_function [ this.Fid != null && this.type() === 'attr' ]
    f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid}%{ Args })

inline_function [ this.Fid != null && this.type() === 'xml' ]
    f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid }%{ Args })

inline_function [ this.Fid != null ]
    f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }%{ Args })

//  Все остальное -- это встроенные функции, для них есть индивидуальные шаблоны ниже.
//  js__internal() вызывает соответствующий шаблон.
inline_function
    %{ js__internal() }

callarg

    , %{ Expr }

// ----------------------------------------------------------------------------------------------------------------- //

internal_function_true
    true

internal_function_false
    false

internal_function_name [ this.Signature === 'nodeset' ]
    this.nodeName( %{Args} )

internal_function_name
    c%{ Cid }.name

internal_function_index
    i%{ Cid }

internal_function_count [ this.Signature === 'nodeset' ]
    ( %{Args} ).length

internal_function_count
    l%{ Cid }

internal_function_slice
    this.slice(%{ Args })

internal_function_html
    %{ Args }

internal_function_exists
    this.exists(%{ Args })

// ----------------------------------------------------------------------------------------------------------------- //

inline_var [ this.def.Value.isConst() ]
    this.v%{ def.Vid }

inline_var
    this.v%{ def.Vid }(c%{ Cid })

inline_number
    %{ Value }

inline_string
    %{ Value }

string_expr
    ( %{ Expr } )

string_literal
    %{ stringify() }



// ----------------------------------------------------------------------------------------------------------------- //
// cast and quote
// ----------------------------------------------------------------------------------------------------------------- //

cast [ this.From === 'nodeset' && (this.To === 'scalar' || this.To === 'xml' || this.To === 'attrvalue' || this.To === 'boolean') ]
    this.nodeset2%{ To }( %{ Expr } )

cast [ this.From === 'scalar' && (this.To === 'xml' || this.To == 'attrvalue') ]
    this.scalar2%{ To }( %{ Expr } )

cast [ this.From === 'xml' && this.To == 'attrvalue' ]
    this.scalar2attrvalue( %{ Expr } )

// FIXME: Не бывает ли ситуации, когда таки нужно нетривиально приводить scalar к boolean?
cast [ this.From === 'scalar' && this.To === 'boolean' ]
    %{ Expr }

cast
    %{ Expr }

quote
    this.%{ Mode }Quote(%{ Expr })

simple_jpath

    this.simpleJPath('%{ Name }', c%{ JPath.Cid })


// ----------------------------------------------------------------------------------------------------------------- //
// misc
// ----------------------------------------------------------------------------------------------------------------- //

* :yate
    %{ yate() }


