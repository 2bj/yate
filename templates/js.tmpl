// vim: set filetype=javascript:

// ----------------------------------------------------------------------------------------------------------------- //
// module
// ----------------------------------------------------------------------------------------------------------------- //

// На первое время, шаблоны (и соответственно matcher) выводятся только на верхнем уровне.

module

    (function() {

        var M = new yr.Module();

        %{ defs :module }

        yr.register('%{ Name }', M);

    })();

// ----------------------------------------------------------------------------------------------------------------- //
// defs: template, function_, key, var_
// ----------------------------------------------------------------------------------------------------------------- //

// template.

template :module

    // match %{ Selector :yate } %{ Mode :yate }
    M.t%{ Tid } = %{ . :def };
    M.t%{ Tid }.s = %{ Selector :selector_ref };

template :def
    function t%{ Tid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid } %{ Args }) {
        %{ Args :defaults }
        %{ . :template_prologue }

        %{ Body :output }

        return r%{ Rid };
    }
//template :template_prologue [ this.type() === 'array' ]
//
//    var r%{ Rid } = [];
//
//template :template_prologue [ this.type() === 'object' ]
//
//    var r%{ Rid } = {};

template :template_prologue

    var r%{ Rid } = '';


// ----------------------------------------------------------------------------------------------------------------- //

// function_

function_ :module

    // func %{ Name }() : %{ type() }
    M.f%{ Fid } = %{ . :def };

function_ :def [ this.Body.inline() ]

    function f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid } %{ Args }) {
        return %{ Body };
    }

function_ :def

    function f%{ Fid }(c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid } %{ Args }) {
        %{ Args :defaults }
        %{ . :function_prologue }

        %{ Body :output }

        %{ . :function_epilogue }
    }

function_ :function_prologue [ this.type() === 'nodeset' ]

    var r%{ Rid } = [];

function_ :function_prologue [ this.type() === 'boolean' ]

    var r%{ Rid } = false;

function_ :function_prologue [ this.type() === 'attr' ]

//  a%{ Rid } = { attrs: {} };

function_ :function_prologue

    var r%{ Rid } = '';

function_ :function_epilogue [ this.type() === 'attr' ]

//  return a%{ Rid }.attrs;

function_ :function_epilogue

    return r%{ Rid };


// ----------------------------------------------------------------------------------------------------------------- //

//  var_

var_ :module
    %{ . :comment }
    M.v%{ Vid } = %{ . :def };

var_ :comment [ this.Value.inline() ]
    //  %{ Name } = %{ Value :yate }

var_ :comment
    //  %{ Name }

var_ :def [ this.Value.inline() && this.Value.isConst() ]
    %{ Value }

var_ :def [ this.Value.inline() ]
    function(c0, i0, l0, a0) {
        return %{ Value };
    }

var_ :def [ this.Value.type() === 'attr' ]
    function(c0, i0, l0, a0) {
        %{ Value :prologue }
        %{ Value :output }
        return a%{ Value.Rid }.attrs;
    }

var_ :def
    function(c0, i0, l0, a0) {
        %{ Value :prologue }
        %{ Value :output }
        return r%{ Value.Rid };
    }

//var_ :defs [ this.Value.inline() && this.Lazy ]
//
//    vars.add("v%{ Vid }", function(c0) { return %{ Value }; });
//
//var_ :defs [ this.Value.inline() ]
//
//    var v%{ Vid } = %{ Value };
//
//var_ :defs [ this.Value.type() === 'attr' && this.Lazy ]
//
//    vars.add("v%{ Vid }", function(c0) {
//        %{ Value :prologue }
//        %{ Value :output }
//        return a%{ Value.Rid }.attrs;
//    });
//
//var_ :defs [ this.Value.type() === 'attr' ]
//
//    %{ Value :prologue }
//    %{ Value :output }
//    var v%{ Vid } = a%{ Value.Rid }.attrs;
//
//var_ :defs [ this.Lazy ]
//
//    vars.add("v%{ Vid }", function(c0) {
//        %{ Value :prologue }
//        %{ Value :output }
//        return r%{ Value.Rid };
//    });
//
//var_ :defs
//
//    %{ Value :prologue }
//    %{ Value :output }
//    var v%{ Vid } = r%{ Value.Rid };


// ----------------------------------------------------------------------------------------------------------------- //

//key :defs
//
//    var k%{ Kid }_nodes;
//    var k%{ Kid }_values = {};
//    var k%{ Kid }_get = function(key) {
//        var value = k%{ Kid }_values[key];
//        if (!value) {
//            var c%{ Cid } = k%{ Kid }_nodes[key];
//            if (c%{ Cid }) {
//                %{ Body.Block :prologue }
//                %{ Body :output }
//                value = r%{ Body.Block.Rid };
//            }
//            if (value) {
//                k%{ Kid }_values[key] = value;
//            }
//        }
//        return value || [];
//    };
//    var k%{ Kid } = function(key) {
//        if (!k%{ Kid }_nodes) {
//            var c%{ Cid } = root[0]; // FIXME: Сделать root[0] отдельной переменной.
//            var nodes = %{ Nodes };
//            k%{ Kid }_nodes = {};
//            for (var i = 0, l = nodes.length; i < l; i++) {
//                var c%{ Use.Cid }= nodes[i];
//                var use = %{ Use };
//                %{ . :use }
//            }
//
//            k%{ Kid } = k%{ Kid }_get;
//        }
//
//        return k%{ Kid }_get(key);
//    };
//
//key :use [ this.Use.type() === 'nodeset' ]
//
//    for (var j = 0, m = use.length; j < m; j++) {
//        k%{ Kid }_nodes[ yater.nodeValue(use[j]) ] = c%{ Use.Cid };
//    }
//
//key :use
//
//    k%{ Kid }_nodes[use] = c%{ Use.Cid };


// ----------------------------------------------------------------------------------------------------------------- //

//  jpath

//  FIXME: Нужно не выводить "простые" jpath'ы, но при этом только те,
//  которые используются только как скаляры.
jpath :module

    // %{ Key }
    M.j%{ Jid } = %{ . :def };

jpath :def

    [ %{ Steps } ]

jpath_nametest

    0, '%{ Name }'

jpath_dots

    1, %{ Length }

jpath_predicate [ this.isLocal() ]

    2, 'p%{ Pid }'

jpath_predicate

    3, 'p%{ Pid }'

// ----------------------------------------------------------------------------------------------------------------- //

//  jpath_predicate

jpath_predicate :module

    // %{ Key }
    M.p%{ Pid } = %{ . :def };

jpath_predicate :def

    function p%{ Pid }(c%{ Cid }, i%{ Cid }, l%{ Cid }) {
// FIXME: Если тут не добавить объявление a0, то ломается тест ../tests/functions.17.yate.
        var a%{ Rid } = null;
        return %{ Expr };
    }


// ----------------------------------------------------------------------------------------------------------------- //
// block and body
// ----------------------------------------------------------------------------------------------------------------- //

body

    %{ Block }

body :output

    %{ Block :output }


// ----------------------------------------------------------------------------------------------------------------- //

block

    %{ Exprs }

block :output

    %{ Exprs :output }

* :prologue [ this.type() === 'nodeset' ]

    var r%{ Rid } = [];

* :prologue [ this.type() === 'boolean' ]

    var r%{ Rid } = false;

* :prologue

    var r%{ Rid } = '';
    var a%{ Rid } = { attrs: {} };


// ----------------------------------------------------------------------------------------------------------------- //
// block expressions
// ----------------------------------------------------------------------------------------------------------------- //

if_ :output [ this.Else ]

    if (%{ Condition }) {
        %{ Then :output }
    } else {
        %{ Else :output }
    }

if_ :output

    if (%{ Condition }) {
        %{ Then :output }
    }

// ----------------------------------------------------------------------------------------------------------------- //

for_ :output

    var items%{ Cid } = %{ Selector };
    for (var i%{ Body.Cid } = 0, l%{ Body.Cid } = items%{ Cid }.length; i%{ Body.Cid } < l%{ Body.Cid }; i%{ Body.Cid }++) {
        var c%{ Body.Cid } = items%{ Cid }[ i%{ Body.Cid } ];
        %{ Body :output }
    }

// ----------------------------------------------------------------------------------------------------------------- //

apply :output [ this.Args && !this.Args.empty() ]

    r%{ Rid } += yater.applyValue(%{ Expr }, %{ Mode :string }, a%{ Rid }, %{ Args });

apply :output

    r%{ Rid } += yater.applyValue(%{ Expr }, %{ Mode :string }, a%{ Rid });

template_mode :string

    '%{ Value }'

// ----------------------------------------------------------------------------------------------------------------- //

xml_attr :open

    '%{ Name }': %{ Value }

xml_line :output

    r%{ Rid } += %{ . :content };

xml_line :content

    %{ js__content() }


// ----------------------------------------------------------------------------------------------------------------- //

// FIXME: Закэшировать a0.attrs в отдельную переменную.
attr :output [ this.Value.inline() && this.Op === '+=' ]
    a%{ Rid }.attrs[ %{ Name } ] = (a%{ Rid }.attrs[ %{ Name } ] || '') + %{ Value };

attr :output [ this.Value.inline() ]
    a%{ Rid }.attrs[ %{ Name } ] %{ Op } %{ Value };

attr :output [ this.Op === '+=' ]

    %{ Value :prologue }
    %{ Value :output }
    a%{ Rid }.attrs[ %{ Name } ] = (a%{ Rid }.attrs[ %{ Name } ] || '') + r%{ Value.Rid };

attr :output

    %{ Value :prologue }
    %{ Value :output }
    a%{ Rid }.attrs[ %{ Name } ] %{ Op } r%{ Value.Rid };

attrs_close :output
    r%{ Rid } += yater.closeAttrs(a%{ Rid });

attrs_open :output

    a%{ Rid }.attrs = {
        %{ Attrs :open }
    };
    a%{ Rid }.start = '%{ Name }';



// ----------------------------------------------------------------------------------------------------------------- //

subexpr :output

    %{ Block :output }



// ----------------------------------------------------------------------------------------------------------------- //
// Selectors: jpath and root.
// ----------------------------------------------------------------------------------------------------------------- //

root

    c0.root

// Для jpath выводим имя его переменной, для root -- null.

root :selector_ref

    null

jpath :selector_ref

    j%{ Jid }

jpath [ this.yate() === '.' ]

    [ c%{ Cid } ]

jpath

    yater.select('j%{ Jid }', c%{ Cid })

// FIXME: Переименовать в inline_filter
jpath_filter

    yater.select('j%{ JPath.Jid }', %{ Expr })



// ----------------------------------------------------------------------------------------------------------------- //

arglist_item
    , v%{ Vid }

arglist_item :defaults [ this.Default ]
    v%{ Vid } = v%{ Vid } || %{ Default };



// ----------------------------------------------------------------------------------------------------------------- //
// inline expressions
// ----------------------------------------------------------------------------------------------------------------- //

value

    %{ Value }

value :output [ ( this.type() === 'nodeset' || this.type() === 'boolean' ) && !this.AsType ]

    r%{ Rid } = %{ Value };

value :output [ this.type() === 'attr' ]

    yater.copyAttrs( a%{ Rid }.attrs, %{ Value } );

value :output

    r%{ Rid } += %{ Value };

//inline_var :inline_output [ this.type() === 'attr' && this.def.Lazy ]
//    yater.copyAttrs( a%{ Rid }.attrs, vars.get("v%{ def.Vid }", c%{ Cid }) );
//
//inline_var :inline_output [ this.type() === 'attr' ]
//    yater.copyAttrs(a%{ Rid }.attrs, v%{ def.Vid });

//* :inline_output [ ( this.type() === 'nodeset' || this.type() === 'boolean' ) && !this.AsType ]
//
//    r%{ Rid } = %{ . };
//
//* :inline_output
//
//    r%{ Rid } += %{ . };

inline_or
    %{ Left } || %{ Right }

inline_and
    %{ Left } && %{ Right }

inline_not
    !%{ Left }

inline_eq
    %{ Left } %{ Op } %{ Right }

inline_rel
    %{ Left } %{ Op } %{ Right }

inline_add
    %{ Left } %{ Op } %{ Right }

inline_mul
    %{ Left } %{ Op } %{ Right }

inline_unary
    -%{ Expr }

inline_union
    (%{ Left }).concat(%{ Right })

inline_subexpr
    (%{ Expr })



// ----------------------------------------------------------------------------------------------------------------- //

inline_function [ this.External && !this.Args.empty() ]
    (Yater.externals['%{ Name }'])(c%{ Cid }, a%{ Rid }, i%{ Cid }, l%{ Cid }, %{ Args })

inline_function [ this.External ]
    (Yater.externals['%{ Name }'])(c%{ Cid }, a%{ Rid }, i%{ Cid }, l%{ Cid })

inline_function [ this.Kid != null ]
    k%{ Kid }(%{ Args }, root)

inline_function [ this.Fid != null && !this.Args.empty() ]
    f%{ Fid }(c%{ Cid }, a%{ Rid }, i%{ Cid }, l%{ Cid }, %{ Args })

inline_function [ this.Fid != null ]
    f%{ Fid }(c%{ Cid }, a%{ Rid }, i%{ Cid }, l%{ Cid })

//  Все остальное -- это встроенные функции, для них есть индивидуальные шаблоны ниже.
//  js__internal() вызывает соответствующий шаблон.
inline_function
    %{ js__internal() }


// ----------------------------------------------------------------------------------------------------------------- //

internal_function_true
    true

internal_function_false
    false

internal_function_name [ this.Signature === 'nodeset' ]
    yater.nodeName( %{Args} )

internal_function_name
    c%{ Cid }.name

internal_function_index
    i%{ Cid }

internal_function_count [ this.Signature === 'nodeset' ]
    ( %{Args} ).length

internal_function_count
    l%{ Cid }

internal_function_slice
    yater.slice(%{ Args })

internal_function_html
    %{ Args }

internal_function_exists
    yater.exists(%{ Args })

// ----------------------------------------------------------------------------------------------------------------- //

inline_var [ this.def.Lazy ]
    vars.get("v%{ def.Vid }", c%{ Cid })

inline_var
    v%{ def.Vid }

inline_number
    %{ Value }

inline_string
    %{ Value }

string_expr
    ( %{ Expr } )

string_literal
    %{ stringify() }



// ----------------------------------------------------------------------------------------------------------------- //
// cast and quote
// ----------------------------------------------------------------------------------------------------------------- //

cast [ this.From === 'nodeset' && (this.To === 'scalar' || this.To === 'xml' || this.To === 'attrvalue' || this.To === 'boolean') ]
    yater.nodeset2%{ To }( %{ Expr } )

cast [ this.From === 'scalar' && (this.To === 'xml' || this.To == 'attrvalue') ]
    yater.scalar2%{ To }( %{ Expr } )

cast [ this.From === 'xml' && this.To == 'attrvalue' ]
    yater.scalar2attrvalue( %{ Expr } )

// FIXME: Не бывает ли ситуации, когда таки нужно нетривиально приводить scalar к boolean?
cast [ this.From === 'scalar' && this.To === 'boolean' ]
    %{ Expr }

cast
    %{ Expr }

quote
    yater.%{ Mode }Quote(%{ Expr })

simple_jpath

    yater.simpleJPath('%{ Name }', c%{ JPath.Cid })


// ----------------------------------------------------------------------------------------------------------------- //
// misc
// ----------------------------------------------------------------------------------------------------------------- //

* :yate
    %{ yate() }


