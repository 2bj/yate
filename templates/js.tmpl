// vim: set filetype=javascript:

// ----------------------------------------------------------------------------------------------------------------- //
// module
// ----------------------------------------------------------------------------------------------------------------- //

// На первое время, шаблоны (и соответственно matcher) выводятся только на верхнем уровне.

module

    (function() {

        var M = new yr.Module();

        %{ Block.js__defs() }

        %{ Block.Templates :defs }

        M.matcher = %{ Block.js__matcher() };

        yr.register('%{ Name }', M);

    })();

// ----------------------------------------------------------------------------------------------------------------- //
// defs: template, function_, key, var_
// ----------------------------------------------------------------------------------------------------------------- //

// template.

template :defs

    // match %{ Selector :yate } %{ Mode :yate }
    M.t%{ Id } = %{ . :def };
    M.t%{ Id }.s = %{ Selector :selector_ref };

template :def
    function t%{ Id }(m, c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid }%{ Args }) {
        %{ Args :defaults }
        %{ . :template_prologue }

        %{ Body :output }

        return r%{ Rid };
    }
//template :template_prologue [ this.type() === 'array' ]
//
//    var r%{ Rid } = [];
//
//template :template_prologue [ this.type() === 'object' ]
//
//    var r%{ Rid } = {};

template :template_prologue

    var r%{ Rid } = '';


// ----------------------------------------------------------------------------------------------------------------- //

// function_

function_ :defs [ this.isGlobal() ]

    // func %{ Name }(%{ Args :yate }) : %{ type() }
    M.f%{ Fid } = %{ . :def };

function_ :defs

    %{ . :def }


//  Только функции с типом attr или xml используют параметр aN.
function_ :def [ this.type() === 'attr' || this.type() === 'xml' ]

    function f%{ Fid }(m, c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid }%{ Args }) {
        %{ . :function_body }
    }

function_ :def

    function f%{ Fid }(m, c%{ Cid }, i%{ Cid }, l%{ Cid }%{ Args }) {
        %{ . :function_body }
    }

//  Тело функции состоит из одного инлайнового выражения (без каких-либо определений).
* :function_body [ this.Body.inline() ]
    %{ Args :defaults }

    return %{ Body };

* :function_body

    %{ Args :defaults }
    %{ . :function_prologue }

    %{ Body :output }

    %{ . :function_epilogue }


* :function_prologue [ this.type() === 'nodeset' ]

    var r%{ Rid } = [];

* :function_prologue [ this.type() === 'boolean' ]

    var r%{ Rid } = false;

//  Функция типа attr не использует переменную rN.
* :function_prologue [ this.type() !== 'attr' ]

    var r%{ Rid } = '';


* :function_epilogue [ this.type() === 'attr' ]

    return a%{ Rid }.attrs;

* :function_epilogue

    return r%{ Rid };


//  ---------------------------------------------------------------------------------------------------------------  //
//  var_
//  ---------------------------------------------------------------------------------------------------------------  //

var_ :body

    %{ Value :prologue }
    %{ Value :output }
    %{ . :epilogue }

var_ :comment

    //  var %{ Name } : %{ Value.type() }


//  Глобальная переменная.
//  ---------------------------------------------------------------------------------------------------------------  //

var_ :defs [ this.isGlobal() ]

    %{ . :comment }
    M.v%{ Id } = %{ . :global };

var_ :global [ this.Value.isConst() ]

    %{ Value }

var_ :global [ this.Value.inline() ]

    function(m, c0, i0, l0) {
        return %{ Value };
    }

var_ :global

    function(m, c0, i0, l0) {
        %{ . :body }
    }

var_ :epilogue [ this.isGlobal() && this.Value.type() === 'attr' ]

    return a%{ Value.Rid }.attrs;

var_ :epilogue [ this.isGlobal() ]

    return r%{ Value.Rid };


//  Локальная переменная
//  ---------------------------------------------------------------------------------------------------------------  //

var_ :defs [ this.Value.inline() ]

    %{ . :comment }
    var v%{ Id } = %{ Value };

var_ :defs

    %{ . :comment }
    %{ . :body }

var_ :epilogue [ this.Value.type() === 'attr' ]

    var v%{ Id } = a%{ Value.Rid }.attrs;

var_ :epilogue

    var v%{ Id } = r%{ Value.Rid };


// ----------------------------------------------------------------------------------------------------------------- //

key :defs

    M.k%{ Id } = {};
    M.k%{ Id }.n = %{ . :nodes };
    //  %{ Use.type() }
    M.k%{ Id }.u = %{ . :use };
    //  %{ Body.type() }
    M.k%{ Id }.b = %{ . :body };
    %{ . :types }

key :nodes

    function k%{ Id }n(m, c0, i0, l0) {
        return %{ Nodes };
    }

key :use

    function k%{ Id }u(m, c0, i0, l0) {
        return %{ Use };
    }

key :body

    function k%{ Id }b(m, c0, i0, l0, a0) {
        %{ . :function_body }
    }

key :types

    M.k%{ Id }.ut = '%{ Use.type() }';
    M.k%{ Id }.bt = '%{ Body.type() }';

// ----------------------------------------------------------------------------------------------------------------- //

//  jpath

jpath :defs
    var j%{ Id } = %{ . :def };

jpath :def

    [ %{ Steps } ]

jpath_nametest

    0, '%{ Name }'

jpath_dots

    1, %{ Length }

jpath_predicate [ this.isLocal() ]

    2, p%{ Id }

jpath_predicate

    3, %{ Expr }

// ----------------------------------------------------------------------------------------------------------------- //

//  jpath_predicate

jpath_predicate :defs [ this.isLocal() ]

    function p%{ Id }(m, c%{ Cid }, i%{ Cid }, l%{ Cid }) {
        return %{ Expr };
    }


// ----------------------------------------------------------------------------------------------------------------- //
// block and body
// ----------------------------------------------------------------------------------------------------------------- //

body

    %{ Block }

body :output

    %{ Block :output }


// ----------------------------------------------------------------------------------------------------------------- //

block

    %{ js__defs() }

    %{ Exprs }

block :output

    %{ js__defs() }

    %{ Exprs :output }

* :prologue [ this.type() === 'nodeset' ]

    var r%{ Rid } = [];

* :prologue [ this.type() === 'boolean' ]

    var r%{ Rid } = false;

* :prologue

    var r%{ Rid } = '';
    var a%{ Rid } = { attrs: {} };


// ----------------------------------------------------------------------------------------------------------------- //
// block expressions
// ----------------------------------------------------------------------------------------------------------------- //

if_ :output [ this.Else ]

    if (%{ Condition }) {
        %{ Then :output }
    } else {
        %{ Else :output }
    }

if_ :output

    if (%{ Condition }) {
        %{ Then :output }
    }

// ----------------------------------------------------------------------------------------------------------------- //

for_ :output

    var items%{ Cid } = %{ Selector };
    for (var i%{ Body.Cid } = 0, l%{ Body.Cid } = items%{ Cid }.length; i%{ Body.Cid } < l%{ Body.Cid }; i%{ Body.Cid }++) {
        var c%{ Body.Cid } = items%{ Cid }[ i%{ Body.Cid } ];
        %{ Body :output }
    }

// ----------------------------------------------------------------------------------------------------------------- //

apply :output

    r%{ Rid } += m.applyValue(%{ Expr }, %{ Mode :string }, a%{ Rid }%{ Args :comma });

template_mode :string

    '%{ Value }'

// ----------------------------------------------------------------------------------------------------------------- //

xml_attr :open

    '%{ Name }': %{ Value }

xml_line :output

    r%{ Rid } += %{ . :content };

xml_line :content

    %{ js__content() }


// ----------------------------------------------------------------------------------------------------------------- //

// FIXME: Закэшировать a0.attrs в отдельную переменную.
attr :output [ this.Value.inline() && this.Op === '+=' ]
    a%{ Rid }.attrs[ %{ Name } ] = (a%{ Rid }.attrs[ %{ Name } ] || '') + %{ Value };

attr :output [ this.Value.inline() ]
    a%{ Rid }.attrs[ %{ Name } ] %{ Op } %{ Value };

attr :output [ this.Op === '+=' ]

    %{ Value :prologue }
    %{ Value :output }
    a%{ Rid }.attrs[ %{ Name } ] = (a%{ Rid }.attrs[ %{ Name } ] || '') + r%{ Value.Rid };

attr :output

    %{ Value :prologue }
    %{ Value :output }
    a%{ Rid }.attrs[ %{ Name } ] %{ Op } r%{ Value.Rid };

attrs_close :output
    r%{ Rid } += m.closeAttrs(a%{ Rid });

attrs_open :output

    a%{ Rid }.attrs = {
        %{ Attrs :open }
    };
    a%{ Rid }.start = '%{ Name }';



// ----------------------------------------------------------------------------------------------------------------- //

subexpr :output

    %{ Block :output }



// ----------------------------------------------------------------------------------------------------------------- //
// Selectors: jpath and root.
// ----------------------------------------------------------------------------------------------------------------- //

root

    c0.root

// Для jpath выводим имя его переменной, для root -- null.

root :selector_ref

    null

jpath :selector_ref

    j%{ Id }

jpath [ this.yate() === '.' ]

    [ c%{ Cid } ]

jpath

    m.selectN(j%{ Id }, c%{ Cid })

// FIXME: Переименовать jpath_filter в inline_filter.

//  root не является nodeset'ом.
jpath_filter [ this.Expr.is('root') ]

    m.selectN(j%{ JPath.Id }, %{ Expr })

jpath_filter

    m.selectNs(j%{ JPath.Id }, %{ Expr })


// ----------------------------------------------------------------------------------------------------------------- //

arglist_item
    , v%{ Id }

arglist_item :defaults [ this.Default ]
    v%{ Id } = v%{ Id } || %{ Default };


// ----------------------------------------------------------------------------------------------------------------- //
//  value
// ----------------------------------------------------------------------------------------------------------------- //

value

    %{ Value }

value :output [ ( this.type() === 'nodeset' || this.type() === 'boolean' ) && !this.AsType ]

    r%{ Rid } = %{ Value };

value :output [ this.type() === 'attr' && this.Value.is('inline_var') ]

    m.copyAttrs( a%{ Rid }.attrs, %{ Value } );

//  А тут всегда Value должно быть inline_function.
value :output [ this.type() === 'attr' ]

    %{ Value };

value :output

    r%{ Rid } += %{ Value };


// ----------------------------------------------------------------------------------------------------------------- //
// inline expressions
// ----------------------------------------------------------------------------------------------------------------- //

inline_or
    %{ Left } || %{ Right }

inline_and
    %{ Left } && %{ Right }

inline_not
    !%{ Left }

inline_eq
    %{ Left } %{ Op } %{ Right }

inline_rel
    %{ Left } %{ Op } %{ Right }

inline_add
    %{ Left } %{ Op } %{ Right }

inline_mul
    %{ Left } %{ Op } %{ Right }

inline_unary
    -%{ Expr }

inline_union
    (%{ Left }).concat(%{ Right })

inline_subexpr
    (%{ Expr })



// ----------------------------------------------------------------------------------------------------------------- //

//  FIXME: Нужно ли тут передавать aN?
inline_function [ this.External ]
    (yr.externals['%{ Name }'])(m, c%{ Cid }, i%{ Cid }, l%{ Cid }, a%{ Rid }%{ Args :comma })

inline_function [ this.IsKey ]
    m.keys('k%{ def.Id }', %{ Args }, c%{ Cid })

inline_function [ this.Fid != null && this.def.isGlobal() ]
    m.funcs('f%{ Fid }', c%{ Cid }, i%{ Cid }, l%{ Cid }%{ . :attrs }%{ Args :comma })

inline_function [ this.Fid != null ]
    f%{ Fid }(m, c%{ Cid }, i%{ Cid }, l%{ Cid }%{ . :attrs }%{ Args :comma })

//  Этот вызов функции сохраняется в переменную, а не просто используется.
//  Поэтому мы передаем вместо aN новый пустой объект для атрибутов.
inline_function :attrs [ this.type() === 'attr' && this.InlineVarValue ]

    , { attrs: {} }

inline_function :attrs [ this.type() === 'attr' || this.type() === 'xml' ]

    , a%{ Rid }

//  Все остальное -- это встроенные функции, для них есть индивидуальные шаблоны ниже.
//  js__internal() вызывает соответствующий шаблон.
inline_function
    %{ js__internal() }

callargs :comma [ !this.empty() ]
    , %{ . }

callarg

    %{ Expr }

// ----------------------------------------------------------------------------------------------------------------- //

internal_function_true
    true

internal_function_false
    false

internal_function_name [ this.Signature === 'nodeset' ]
    m.nodeName( %{Args} )

internal_function_name
    c%{ Cid }.name

internal_function_index
    i%{ Cid }

internal_function_count [ this.Signature === 'nodeset' ]
    ( %{Args} ).length

internal_function_count
    l%{ Cid }

internal_function_slice
    m.slice(%{ Args })

internal_function_html
    %{ Args }

internal_function_exists
    m.exists(%{ Args })

// ----------------------------------------------------------------------------------------------------------------- //

inline_var [ this.def.isGlobal() && this.def.isConst() ]

    m.v%{ def.Id }

inline_var [ this.def.isGlobal() ]

    m.vars('v%{ def.Id }', c%{ Cid })

inline_var
    v%{ def.Id }

//  ---------------------------------------------------------------------------------------------------------------  //

inline_number
    %{ Value }

inline_string
    %{ Value }

string_expr
    ( %{ Expr } )

string_literal
    %{ stringify() }



// ----------------------------------------------------------------------------------------------------------------- //
// cast and quote
// ----------------------------------------------------------------------------------------------------------------- //

cast [ this.From === 'nodeset' && (this.To === 'scalar' || this.To === 'xml' || this.To === 'attrvalue' || this.To === 'boolean') ]
    m.nodeset2%{ To }( %{ Expr } )

cast [ this.From === 'scalar' && (this.To === 'xml' || this.To == 'attrvalue') ]
    m.scalar2%{ To }( %{ Expr } )

cast [ this.From === 'xml' && this.To == 'attrvalue' ]
    m.scalar2attrvalue( %{ Expr } )

// FIXME: Не бывает ли ситуации, когда таки нужно нетривиально приводить scalar к boolean?
cast [ this.From === 'scalar' && this.To === 'boolean' ]
    %{ Expr }

cast
    %{ Expr }

quote
    m.%{ Mode }Quote(%{ Expr })

simple_jpath

    m.simpleJPath('%{ Name }', c%{ JPath.Cid })


// ----------------------------------------------------------------------------------------------------------------- //
// misc
// ----------------------------------------------------------------------------------------------------------------- //

* :yate
    %{ yate() }


